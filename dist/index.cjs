var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// Game/Assets/Fonts.js
var smallFiGlet = [
  /*
      0-9: 0-9
      10-35: A-Z
      36-61: a-z
      62: space
  */
  [
    `  __  `,
    ` /  \\ `,
    `| () |`,
    ` \\__/ `
  ],
  [
    ` _ `,
    `/ |`,
    `| |`,
    `|_|`
  ],
  [
    ` ___ `,
    `|_  )`,
    ` / / `,
    `/___|`
  ],
  [
    ` ____`,
    `|__ /`,
    ` |_ \\`,
    `|___/`
  ],
  [
    ` _ _  `,
    `| | | `,
    `|_  _|`,
    `  |_| `
  ],
  [
    ` ___ `,
    `| __|`,
    `|__ \\`,
    `|___/`
  ],
  [
    `  __ `,
    ` / / `,
    `/ _ \\`,
    `\\___/`
  ],
  [
    ` ____ `,
    `|__  |`,
    `  / / `,
    ` /_/  `
  ],
  [
    ` ___ `,
    `( _ )`,
    `/ _ \\`,
    `\\___/`
  ],
  [
    ` ___ `,
    `/ _ \\`,
    `\\_, /`,
    ` /_/ `
  ],
  [
    ` _ `,
    `(_)`,
    ` _ `,
    `(_)`
  ],
  [
    ` _ `,
    `(_)`,
    ` _ `,
    `( )`,
    `|/ `
  ],
  [
    `  __`,
    ` / /`,
    `< < `,
    ` \\_\\`
  ],
  [
    ` ___ `,
    `|___|`,
    `|___|`
  ],
  [
    `__  `,
    `\\ \\ `,
    ` > >`,
    `/_/ `
  ],
  [
    ` ___ `,
    `|__ \\`,
    `  /_/`,
    ` (_) `
  ],
  [
    `  ____  `,
    ` / __ \\ `,
    `/ / _\` |`,
    `\\ \\__,_|`,
    ` \\____/ `
  ],
  [
    `   _   `,
    `  /_\\  `,
    ` / _ \\ `,
    `/_/ \\_\\`
  ],
  [
    ` ___ `,
    `| _ )`,
    `| _ \\`,
    `|___/`
  ],
  [
    `  ___ `,
    ` / __|`,
    `| (__ `,
    ` \\___|`
  ],
  [
    ` ___  `,
    `|   \\ `,
    `| |) |`,
    `|___/ `
  ],
  [
    ` ___ `,
    `| __|`,
    `| _| `,
    `|___|`
  ],
  [
    ` ___ `,
    `| __|`,
    `| _| `,
    `|_|  `
  ],
  [
    `  ___ `,
    ` / __|`,
    `| (_ |`,
    ` \\___|`
  ],
  [
    ` _  _ `,
    `| || |`,
    `| __ |`,
    `|_||_|`
  ],
  [
    ` ___ `,
    `|_ _|`,
    ` | | `,
    `|___|`
  ],
  [
    `    _ `,
    ` _ | |`,
    `| || |`,
    ` \\__/ `
  ],
  [
    ` _  __`,
    `| |/ /`,
    `| ' < `,
    `|_|\\_\\`
  ],
  [
    ` _    `,
    `| |   `,
    `| |__ `,
    `|____|`
  ],
  [
    ` __  __ `,
    `|  \\/  |`,
    `| |\\/| |`,
    `|_|  |_|`
  ],
  [
    ` _  _ `,
    `| \\| |`,
    `| .\` |`,
    `|_|\\_|`
  ],
  [
    `  ___  `,
    ` / _ \\ `,
    `| (_) |`,
    ` \\___/ `
  ],
  [
    ` ___ `,
    `| _ \\`,
    `|  _/`,
    `|_|  `
  ],
  [
    `  ___  `,
    ` / _ \\ `,
    `| (_) |`,
    ` \\__\\_\\`
  ],
  [
    ` ___ `,
    `| _ \\`,
    `|   /`,
    `|_|_\\`
  ],
  [
    ` ___ `,
    `/ __|`,
    `\\__ \\`,
    `|___/`
  ],
  [
    ` _____ `,
    `|_   _|`,
    `  | |  `,
    `  |_|  `
  ],
  [
    ` _   _ `,
    `| | | |`,
    `| |_| |`,
    ` \\___/ `
  ],
  [
    `__   __`,
    `\\ \\ / /`,
    ` \\ V / `,
    `  \\_/  `
  ],
  [
    `__      __`,
    `\\ \\    / /`,
    ` \\ \\/\\/ / `,
    `  \\_/\\_/  `
  ],
  [
    `__  __`,
    `\\ \\/ /`,
    ` >  < `,
    `/_/\\_\\`
  ],
  [
    `__   __`,
    `\\ \\ / /`,
    ` \\ V / `,
    `  |_|  `
  ],
  [
    ` ____`,
    `|_  /`,
    ` / / `,
    `/___|`
  ],
  [
    ` __ `,
    `| _|`,
    `| | `,
    `| | `,
    `|__|`
  ],
  [
    `__   `,
    `\\ \\  `,
    ` \\ \\ `,
    `  \\_\\`
  ],
  [
    ` __ `,
    `|_ |`,
    ` | |`,
    ` | |`,
    `|__|`
  ],
  [
    ` /\\ `,
    `|/\\|`
  ],
  [
    ` ___ `,
    `|___|`
  ],
  [
    ` _ `,
    `( )`,
    ` \\|`
  ],
  [
    ` __ _ `,
    `/ _\` |`,
    `\\__,_|`
  ],
  [
    ` _    `,
    `| |__ `,
    `| '_ \\`,
    `|_.__|`
  ],
  [
    ` __ `,
    `/ _|`,
    `\\__|`
  ],
  [
    `    _ `,
    ` __| |`,
    `/ _\` |`,
    `\\__,_|`
  ],
  [
    ` ___ `,
    `/ -_)`,
    `\\___|`
  ],
  [
    `  __ `,
    ` / _|`,
    `|  _|`,
    `|_|  `
  ],
  [
    ` __ _ `,
    `/ _\` |`,
    `\\__, |`,
    `|___/ `
  ],
  [
    ` _    `,
    `| |_  `,
    `| ' \\ `,
    `|_||_|`
  ],
  [
    ` _ `,
    `(_)`,
    `| |`,
    `|_|`
  ],
  [
    `   _ `,
    `  (_)`,
    `  | |`,
    ` _/ |`,
    `|__/ `
  ],
  [
    ` _   `,
    `| |__`,
    `| / /`,
    `|_\\_\\`
  ],
  [
    ` _ `,
    `| |`,
    `| |`,
    `|_|`
  ],
  [
    ` _ __  `,
    `| '  \\ `,
    `|_|_|_|`
  ],
  [
    ` _ _  `,
    `| ' \\ `,
    `|_||_|`
  ],
  [
    ` ___ `,
    `/ _ \\`,
    `\\___/`
  ],
  [
    ` _ __ `,
    `| '_ \\`,
    `| .__/`,
    `|_|   `
  ],
  [
    ` __ _ `,
    `/ _\` |`,
    `\\__, |`,
    `   |_|`
  ],
  [
    ` _ _ `,
    `| '_|`,
    `|_|  `
  ],
  [
    ` ___`,
    `(_-<`,
    `/__/`
  ],
  [
    ` _   `,
    `| |_ `,
    `|  _|`,
    ` \\__|`
  ],
  [
    ` _  _ `,
    `| || |`,
    ` \\_,_|`
  ],
  [
    `__ __`,
    `\\ V /`,
    ` \\_/ `
  ],
  [
    `__ __ __`,
    `\\ V  V /`,
    ` \\_/\\_/ `
  ],
  [
    `__ __`,
    `\\ \\ /`,
    `/_\\_\\`
  ],
  [
    ` _  _ `,
    `| || |`,
    ` \\_, |`,
    ` |__/ `
  ],
  [
    ` ___`,
    `|_ /`,
    `/__|`
  ],
  [
    ` `,
    ` `,
    ` `,
    ` `
  ],
  [
    ` _  `,
    `| | `,
    `|_| `,
    `(_) `
  ],
  [
    `###`,
    `###`,
    `###`,
    `###`
  ]
];
var getChar = (char) => {
  const code = char.charCodeAt(0);
  if (code >= 48 && code <= 57) {
    return smallFiGlet[code - 48];
  } else if (code >= 65 && code <= 90) {
    return smallFiGlet[code - 65 + 17];
  } else if (code >= 97 && code <= 122) {
    return smallFiGlet[code - 97 + 49];
  } else if (char == ":") {
    return smallFiGlet[10];
  } else if (char == ";") {
    return smallFiGlet[11];
  } else if (char == "(") {
    return smallFiGlet[12];
  } else if (char == ")") {
    return smallFiGlet[14];
  } else if (char == "?") {
    return smallFiGlet[15];
  } else if (char == "@") {
    return smallFiGlet[16];
  } else if (char == "[") {
    return smallFiGlet[43];
  } else if (char == "\\") {
    return smallFiGlet[44];
  } else if (char == "]") {
    return smallFiGlet[45];
  } else if (char == "^") {
    return smallFiGlet[46];
  } else if (char == ".") {
    return smallFiGlet[47];
  } else if (char == ",") {
    return smallFiGlet[48];
  } else if (char == "!") {
    return smallFiGlet[76];
  } else if (char == " ") {
    return smallFiGlet[75];
  } else {
    return smallFiGlet[77];
  }
};
var mergeChars = (char1, char2) => {
  const merged = [];
  const height = Math.max(char1.length, char2.length);
  if (char1.length == 0) {
    return char2;
  }
  if (char2.length == 0) {
    return char1;
  }
  if (char1.length < height) {
    for (let i = char1.length; i < height; i++) {
      char1.unshift(" ".repeat(char1[0].length));
    }
  }
  if (char2.length < height) {
    for (let i = char2.length; i < height; i++) {
      char2.unshift(" ".repeat(char2[0].length));
    }
  }
  const f_width = char1[0].length;
  const s_width = char2[0].length;
  for (let i = 0; i < height; i++) {
    let line = char1[i] + char2[i];
    merged.push(line);
  }
  return merged;
};
var getFiGlet = (str) => {
  const chars = str.split("");
  let merged = [];
  for (let i = 0; i < chars.length; i++) {
    merged = mergeChars(merged, getChar(chars[i]));
  }
  return merged.join("\n");
};

// Game/Base/ConsoleHelp.js
var ControlSequences = class {
  static get CSI() {
    return "\x1B[";
  }
  static get OSC() {
    return "\x1B]";
  }
  static get Reset() {
    return "\x1B[0m";
  }
};
var DefaultColors = class {
  static #BLACK = 30;
  static #RED = 31;
  static #GREEN = 32;
  static #YELLOW = 33;
  static #BLUE = 34;
  static #MAGENTA = 35;
  static #CYAN = 36;
  static #WHITE = 37;
  static #LIGHTBLACK_EX = 90;
  static #LIGHTRED_EX = 91;
  static #LIGHTGREEN_EX = 92;
  static #LIGHTYELLOW_EX = 93;
  static #LIGHTBLUE_EX = 94;
  static #LIGHTMAGENTA_EX = 95;
  static #LIGHTCYAN_EX = 96;
  static #LIGHTWHITE_EX = 97;
  static #BG_BLACK = 40;
  static #BG_RED = 41;
  static #BG_GREEN = 42;
  static #BG_YELLOW = 43;
  static #BG_BLUE = 44;
  static #BG_MAGENTA = 45;
  static #BG_CYAN = 46;
  static #BG_WHITE = 47;
  static #BG_RESET = 49;
  static get BLACK() {
    return this.#BLACK;
  }
  static set BLACK(value) {
    this.#BLACK = value;
  }
  static get RED() {
    return this.#RED;
  }
  static set RED(value) {
    this.#RED = value;
  }
  static get GREEN() {
    return this.#GREEN;
  }
  static set GREEN(value) {
    this.#GREEN = value;
  }
  static get YELLOW() {
    return this.#YELLOW;
  }
  static set YELLOW(value) {
    this.#YELLOW = value;
  }
  static get BLUE() {
    return this.#BLUE;
  }
  static set BLUE(value) {
    this.#BLUE = value;
  }
  static get MAGENTA() {
    return this.#MAGENTA;
  }
  static set MAGENTA(value) {
    this.#MAGENTA = value;
  }
  static get CYAN() {
    return this.#CYAN;
  }
  static set CYAN(value) {
    this.#CYAN = value;
  }
  static get WHITE() {
    return this.#WHITE;
  }
  static set WHITE(value) {
    this.#WHITE = value;
  }
  static get LIGHTBLACK_EX() {
    return this.#LIGHTBLACK_EX;
  }
  static set LIGHTBLACK_EX(value) {
    this.#LIGHTBLACK_EX = value;
  }
  static get LIGHTRED_EX() {
    return this.#LIGHTRED_EX;
  }
  static set LIGHTRED_EX(value) {
    this.#LIGHTRED_EX = value;
  }
  static get LIGHTGREEN_EX() {
    return this.#LIGHTGREEN_EX;
  }
  static set LIGHTGREEN_EX(value) {
    this.#LIGHTGREEN_EX = value;
  }
  static get LIGHTYELLOW_EX() {
    return this.#LIGHTYELLOW_EX;
  }
  static set LIGHTYELLOW_EX(value) {
    this.#LIGHTYELLOW_EX = value;
  }
  static get LIGHTBLUE_EX() {
    return this.#LIGHTBLUE_EX;
  }
  static set LIGHTBLUE_EX(value) {
    this.#LIGHTBLUE_EX = value;
  }
  static get LIGHTMAGENTA_EX() {
    return this.#LIGHTMAGENTA_EX;
  }
  static set LIGHTMAGENTA_EX(value) {
    this.#LIGHTMAGENTA_EX = value;
  }
  static get LIGHTCYAN_EX() {
    return this.#LIGHTCYAN_EX;
  }
  static set LIGHTCYAN_EX(value) {
    this.#LIGHTCYAN_EX = value;
  }
  static get LIGHTWHITE_EX() {
    return this.#LIGHTWHITE_EX;
  }
  static set LIGHTWHITE_EX(value) {
    this.#LIGHTWHITE_EX = value;
  }
  static get BG_BLACK() {
    return this.#BG_BLACK;
  }
  static set BG_BLACK(value) {
    this.#BG_BLACK = value;
  }
  static get BG_RED() {
    return this.#BG_RED;
  }
  static set BG_RED(value) {
    this.#BG_RED = value;
  }
  static get BG_GREEN() {
    return this.#BG_GREEN;
  }
  static set BG_GREEN(value) {
    this.#BG_GREEN = value;
  }
  static get BG_YELLOW() {
    return this.#BG_YELLOW;
  }
  static set BG_YELLOW(value) {
    this.#BG_YELLOW = value;
  }
  static get BG_BLUE() {
    return this.#BG_BLUE;
  }
  static set BG_BLUE(value) {
    this.#BG_BLUE = value;
  }
  static get BG_MAGENTA() {
    return this.#BG_MAGENTA;
  }
  static set BG_MAGENTA(value) {
    this.#BG_MAGENTA = value;
  }
  static get BG_CYAN() {
    return this.#BG_CYAN;
  }
  static set BG_CYAN(value) {
    this.#BG_CYAN = value;
  }
  static get BG_WHITE() {
    return this.#BG_WHITE;
  }
  static set BG_WHITE(value) {
    this.#BG_WHITE = value;
  }
  static get BG_RESET() {
    return this.#BG_RESET;
  }
  static set BG_RESET(value) {
    this.#BG_RESET = value;
  }
  /// Custom colors 8 bit
  /// 0-7: standard colors (as in DefaultColors.Color)
  /// if num is an array of exactly 3 numbers, it will be a 24bit RGB color
  static custom_colors(num, background = false) {
    let text = "38";
    if (background) {
      text = "48";
    }
    if (Array.isArray(num)) {
      if (num.length === 3) {
        text += `;2;${num[0]};${num[1]};${num[2]}`;
      } else {
        return text + `;5;${num[0]}`;
      }
      return text;
    } else {
      return text + `;5;${num}`;
    }
  }
};
var Decorations = class {
  static get Bold() {
    return 1;
  }
  static get Dim() {
    return 2;
  }
  static get Italic() {
    return 3;
  }
  static get Underlined() {
    return 4;
  }
  static get Blink() {
    return 5;
  }
  static get Reverse() {
    return 7;
  }
  static get Strikethrough() {
    return 9;
  }
  static get no_underline() {
    return 24;
  }
};
var ConsoleNotImplemented = class extends Error {
  constructor() {
    super("The ConsoleHelper was not properly implemented.");
    this.name = "ConsoleError";
  }
};
var ConsoleImplementation = class {
  //
  // Strictly Abstract 
  //
  // Should only throw error if a not implement NESCESSARY feature is tryng to be used
  fillBar = () => {
    throw new ConsoleNotImplemented();
  };
  insert_color = () => {
    throw new ConsoleNotImplemented();
  };
  insert_format = () => {
    throw new ConsoleNotImplemented();
  };
  clear_screen = () => {
    throw new ConsoleNotImplemented();
  };
  clear_line = () => {
    throw new ConsoleNotImplemented();
  };
  clear_last_line = () => {
    throw new ConsoleNotImplemented();
  };
  getWidth = () => {
    throw new ConsoleNotImplemented();
  };
  show_cursor = () => {
    throw new ConsoleNotImplemented();
  };
  print = () => {
    throw new ConsoleNotImplemented();
  };
  setTitle = () => {
    throw new ConsoleNotImplemented();
  };
};
var BasicConsole = class _BasicConsole extends ConsoleImplementation {
  static #instance = null;
  //Singleton instance
  constructor() {
    if (_BasicConsole.#instance) {
      return _BasicConsole.#instance;
    } else {
      super();
      _BasicConsole.#instance = this;
    }
  }
  /// Already done by the constructor
  /// but here for completeness sake.
  getInstance() {
    return _BasicConsole.#instance;
  }
  breakLine = (text, width, ignorenl = false) => {
    if (ignorenl) {
      text = text.replaceAll("\n", " ");
    }
    let words = text.split(" ");
    let lines = [];
    let line = "";
    words.forEach((word) => {
      const lineLength = this.getLineWidth(line);
      const wordLength = this.getLineWidth(word);
      if (lineLength + wordLength > width) {
        lines.push(line);
        line = "";
      }
      line += word + " ";
    });
    lines.push(line);
    return lines.join("\n");
  };
  clear_screen = () => {
    console.clear();
  };
  write = (text) => {
    process.stdout.write(text);
  };
  clear_line = () => {
    this.write(ControlSequences.CSI + `2K`);
  };
  clear_last_line = (times) => {
    for (let i = 0; i < (times || 1); i++) {
      this.write("\x1B[1A");
      this.clear_line();
    }
  };
  getWidth = () => {
    return process.stdout.columns;
  };
  show_cursor = (value = true) => {
    if (value)
      this.write("\x1B[?25h");
    else
      this.write("\x1B[?25l");
  };
  insert_color = (color, text, oldColor) => {
    return ControlSequences.CSI + color + `m` + text + ControlSequences.Reset;
  };
  insert_format = (format = {
    color: DefaultColors.WHITE,
    background: DefaultColors.BLACK,
    decoration: Decorations.None
  }, text) => {
    if (!text) return "";
    if (text.includes(ControlSequences.Reset)) {
      const color = format.color || DefaultColors.WHITE;
      text = text.replaceAll(ControlSequences.Reset, ControlSequences.CSI + color + `m`);
    }
    let fmt = "";
    let addSemi = false;
    if (format.color) {
      fmt += format.color;
      addSemi = true;
    }
    if (format.background) {
      if (addSemi)
        fmt += ";";
      fmt += format.background;
      addSemi = true;
    }
    if (format.decoration) {
      let decorationArray = [];
      if (!Array.isArray(format.decoration))
        decorationArray = [format.decoration];
      else
        decorationArray = format.decoration;
      decorationArray.forEach((item) => {
        if (addSemi)
          fmt += ";";
        fmt += item;
        addSemi = true;
      });
    }
    return ControlSequences.CSI + fmt + `m` + text + ControlSequences.Reset;
  };
  fillBar = (percent, size, char, color, bg_color) => {
    if (typeof percent !== "number")
      throw new Error("Percent must be a number");
    if (typeof size !== "number" || size < 1)
      throw new Error("Size must be a positive integer");
    if (typeof char !== "string" || char.length !== 1)
      throw new Error("Char must be exactly 1 char");
    percent = Math.max(percent, 0);
    percent = Math.min(percent, 1);
    const cut_off = Math.round(percent * size);
    let line = this.insert_color(color, char.repeat(cut_off)) + this.insert_color(bg_color, char.repeat(size - cut_off));
    return line;
  };
  printOptions = (options, selectIndex = 0, config, vertical = false) => {
    let res = "";
    const padChar = " ";
    let padding = padChar.repeat(3);
    if (config && config.padding) {
      padding = padChar.repeat(config.padding);
    }
    const width = this.getWidth();
    const totalLength = options.reduce((acc, item) => acc + item.length, 0) + padding.length * options.length;
    if (totalLength > width) {
      padding = " ".repeat(0);
    }
    for (let i = 0; i < options.length; i++) {
      let line = `  ${options[i]}  `;
      if (i === selectIndex)
        line = `> ${options[i]} <`;
      if (vertical) {
        res += this.hcenter(line, width, padChar);
        res += "\n";
      } else {
        res += line;
        res += padding;
      }
    }
    res = this.hcenter(res, width);
    if (this.getLineWidth(res) > width && !vertical) {
      res = res.substring(0, width);
    }
    res = res.replace(options[selectIndex], this.insert_format({
      decoration: Decorations.Underlined
    }, options[selectIndex]));
    res = res.replaceAll(">", this.insert_color(DefaultColors.YELLOW, ">"));
    res = res.replaceAll("<", this.insert_color(DefaultColors.YELLOW, "<"));
    if (config && Array.isArray(config.colors)) {
      config.colors.forEach((item) => {
        res = res.replaceAll(item.text, this.insert_color(item.color, item.text));
      });
    }
    this.print(res);
    return res;
  };
  // Horizontal center a line, mode => 0 = center, 1 = left, 2 = right
  // MultiLine text is supported, each line will be centered
  // if treatAsRaw is true, it will treat the input as a single line
  hcenter = (input, size = -1, char = " ", mode = 0) => {
    if (typeof input !== "string") return "";
    if (size < 0) {
      size = this.getWidth();
    }
    const centerLine = (text) => {
      if (typeof text !== "string") return void 0;
      let start = mode !== 1;
      while (this.getLineWidth(text) < size) {
        if (start) text = char + text;
        else text += char;
        if (mode === 0)
          start = !start;
      }
      return text;
    };
    if (input.includes("\n")) {
      let lines = input.split("\n");
      const maxLength = Math.max(...lines.map((line) => this.getLineWidth(line)));
      lines = lines.map((line) => {
        while (this.getLineWidth(line) < maxLength) {
          line += " ";
        }
        return line;
      });
      lines = lines.map((line) => centerLine(line));
      return lines.join("\n");
    }
    return centerLine(input);
  };
  // Vertical center a sprite, mode => 0 = center, 1 = top, 2 = bottom
  // input should be an array of strings
  vcenter = (input, verticalLength, horizontalLength, char = " ", mode = 0) => {
    const diff = verticalLength - input.length;
    let center = mode === 2;
    for (let i = 0; i < diff; i++) {
      if (center)
        input.push(char.repeat(horizontalLength));
      else
        input.unshift(char.repeat(horizontalLength));
      if (mode === 0)
        center = !center;
    }
    return input;
  };
  // Merge two sprites to be printed together
  // If you need Colors, you can pass an array of objects with the text and color
  // but only use at the last merged you do before printing to the console.
  merge = (leftSprite, rightSprite, options = {}) => {
    if (typeof leftSprite !== "string" || typeof rightSprite !== "string") return void 0;
    console.log(options);
    let rightLines = rightSprite.split("\n");
    let leftLines = leftSprite.split("\n");
    const maxLengthLeft = Math.max(...leftLines.map((line) => this.getLineWidth(line)));
    const maxLengthRight = Math.max(...rightLines.map((line) => this.getLineWidth(line)));
    if (options.left && options.left.align) {
      if (options.left.align === "hcenter") {
        leftLines = leftLines.map((line) => this.hcenter(line, maxLengthLeft, " "));
      } else if (options.left.align === "vcenter") {
        this.vcenter(leftLines, rightLines.length, maxLengthLeft, " ");
      }
    }
    if (options.right && options.right.align) {
      if (options.right.align === "hcenter") {
        rightLines = rightLines.map((line) => this.hcenter(line, maxLengthRight, " "));
      } else if (options.right.align === "vcenter") {
        this.vcenter(rightLines, leftLines.length, maxLengthRight, " ");
      }
    }
    if (leftLines.length < rightLines.length)
      this.vcenter(leftLines, rightLines.length, maxLengthLeft, " ", 2);
    let mergedLines = leftLines.map((line, index) => {
      const sentenceLine = rightLines[index] || " ".repeat(maxLengthRight);
      let padding = options.padding || 4;
      if (options?.padding == 0)
        padding = 0;
      return line.padEnd(maxLengthLeft, " ") + " ".repeat(padding) + sentenceLine;
    }).join("\n");
    if (Array.isArray(options.colors)) {
      options.colors.forEach((item) => {
        if (Array.isArray(item.text)) {
          item.text.forEach((text) => mergedLines = mergedLines.replaceAll(text, this.insert_color(item.color, text)));
        } else
          mergedLines = mergedLines.replaceAll(item.text, this.insert_color(item.color, item.text));
      });
    }
    return mergedLines;
  };
  paintSprite = (sprite, hcutoff, color) => {
    const sprite_array = sprite.split("\n");
    let res = "";
    sprite_array.forEach((element) => {
      res += this.insert_color(color, element.substring(0, hcutoff));
      res += element.substring(hcutoff);
      res += "\n";
    });
    return res;
  };
  getLineWidth = (text) => {
    if (!text) return 0;
    let line = text;
    while (line.includes(ControlSequences.CSI)) {
      const csi_index = line.indexOf(ControlSequences.CSI);
      const end_csi = line.indexOf("m", csi_index);
      let end = "";
      if (end_csi + 1 < line.length && end_csi > 0)
        end = line.substring(end_csi + 1);
      line = line.substring(0, csi_index) + end;
    }
    return line.length;
  };
  pressSpace = (phrase = "to continue") => {
    const width = this.getWidth();
    let final_phrase = `Press Spacebar ${phrase}.`;
    final_phrase = this.hcenter(final_phrase, width);
    final_phrase = final_phrase.replaceAll(
      "Spacebar",
      this.insert_format({
        color: DefaultColors.YELLOW,
        decoration: [Decorations.Underlined, Decorations.Blink]
      }, "Space")
    );
    this.print(final_phrase);
  };
  print = (text) => {
    if (typeof text === "undefined") {
      this.write("\n");
    } else {
      this.write(text + "\n");
    }
  };
  controlPrint = (text) => {
    if (typeof text === "undefined") {
      this.write("\n");
      return 1;
    } else {
      this.write(text + "\n");
      let startindex = 0;
      let count = 1;
      while (startindex != -1) {
        startindex = text.indexOf("\n", startindex);
        if (startindex != -1) {
          count++;
          startindex++;
        }
      }
      return count;
    }
  };
  setTitle = (title) => {
    this.write("\x1B]2;" + title + "\x1B\\");
  };
  hprint = (text) => {
    if (typeof text === "undefined") {
      this.write("\n");
    } else
      this.write(this.hcenter(text, this.getWidth()) + "\n");
  };
  // Get a substring of a string, ignoring escape sequences
  // start and end are the indexes of the text without escape sequences
  getSafeSubstring = (text, start, end) => {
    if (typeof text !== "string") return "";
    if (end > text.length) end = text.length;
    let trueIndex = 0;
    let startIndex = 0;
    let endIndex = text.length - 1;
    let cmd = false;
    let openEsc = false;
    let openEscIndex = 0;
    for (let i = 0; i < text.length; i++) {
      if (cmd == true) {
        if (text[i] == "m") {
          cmd = false;
        }
      } else if (cmd == false) {
        if (text[i] == "\x1B") {
          cmd = true;
          openEsc = !openEsc;
          if (openEsc) {
            openEscIndex = i;
          } else
            openEscIndex = -1;
        } else {
          if (trueIndex == start) {
            if (openEsc) {
              startIndex = openEscIndex;
            } else
              startIndex = i;
          }
          if (trueIndex == end) {
            endIndex = i;
            break;
          }
          trueIndex++;
        }
      }
    }
    let res = text.substring(startIndex, endIndex + 1);
    if (openEsc == true || cmd == true) {
      res += ControlSequences.Reset;
    }
    return res;
  };
  animate = (sprite, ms, onEnd = null, center = false) => {
    const textArray = sprite.split("\n");
    const hval = Math.max(...textArray.map((item) => this.getLineWidth(item)));
    const get_partial = (sprite2, index) => {
      let res = "";
      sprite2.forEach((element) => {
        let line = this.getSafeSubstring(element, 0, index);
        if (center) {
          line = this.hcenter(line);
        }
        res += line;
        res += "\n";
      });
      return res;
    };
    const render = (index) => {
      this.clear_screen();
      this.print(get_partial(textArray, index));
      if (index < hval) {
        setTimeout(() => {
          render(index + 1);
        }, ms);
      } else {
        if (onEnd) {
          onEnd();
        }
      }
    };
    render(0);
  };
  paint = (sprite, color) => {
    const sprite_array = sprite.split("\n");
    let res = "";
    sprite_array.forEach((element) => {
      res += this.insert_color(color, element);
      res += "\n";
    });
    return res;
  };
  printFigLet = (text, options) => {
    let figlet = getFiGlet(text);
    const center = options?.center || true;
    if (options?.color) {
      figlet = this.insert_color(options?.color, figlet);
    }
    if (options?.format) {
      figlet = this.insert_format(options?.format, figlet);
    }
    if (center) {
      figlet = this.hcenter(figlet);
    }
    this.print(figlet);
  };
};

// Game/Assets/Assets.js
var CH = new BasicConsole();
var Colors = DefaultColors;
var Logos = class _Logos {
  static get MattediWorks() {
    return `
 __  __         _    _             _  _ __          __           _         
|  \\/  |       | |  | |           | |(_)\\ \\        / /          | |        
| \\  / |  __ _ | |_ | |_  ___   __| | _  \\ \\  /\\  / /___   _ __ | | __ ___ 
| |\\/| | / _\` || __|| __|/ _ \\ / _\` || |  \\ \\/  \\/ // _ \\ | '__|| |/ // __|
| |  | || (_| || |_ | |_|  __/| (_| || |   \\  /\\  /| (_) || |   |   < \\__ \\
|_|  |_| \\__,_| \\__| \\__|\\___| \\__,_||_|    \\/  \\/  \\___/ |_|   |_|\\_\\|___/
`;
  }
  static get Mattedi() {
    return ` __  __         _    _             _  _ 
|  \\/  |       | |  | |           | |(_)
| \\  / |  __ _ | |_ | |_  ___   __| | _ 
| |\\/| | / _\` || __|| __|/ _ \\ / _\` || |
| |  | || (_| || |_ | |_|  __/| (_| || |
|_|  |_| \\__,_| \\__| \\__|\\___| \\__,_||_|`;
  }
  static get Works() {
    return `__          __           _         
\\ \\        / /          | |        
 \\ \\  /\\  / /___   _ __ | | __ ___ 
  \\ \\/  \\/ // _ \\ | '__|| |/ // __|
   \\  /\\  /| (_) || |   |   < \\__ \\
    \\/  \\/  \\___/ |_|   |_|\\_\\|___/`;
  }
  static get ConsoleAdventure() {
    return `
    ___                      _          _       _                 _                  
   / __\\___  _ __  ___  ___ | | ___    /_\\   __| |_   _____ _ __ | |_ _   _ _ __ ___ 
  / /  / _ \\| '_ \\/ __|/ _ \\| |/ _ \\  //_\\\\ / _\` \\ \\ / / _ | '_ \\| __| | | | '__/ _ \\
 / /__| (_) | | | \\__ | (_) | |  __/ /  _  | (_| |\\ V |  __| | | | |_| |_| | | |  __/
/____/ \\___/|_| |_|___/\\___/|_|\\___| \\_/ \\_/\\__,_| \\_/ \\___|_| |_|\\__|\\__,_|_|  \\___|
                                                                                  
`;
  }
  static get ca_cutoff() {
    return 36;
  }
  static get mw_cutoff() {
    return 39;
  }
  static animatedSynced = (logo, ms, color = { color: Colors.RED, index: 1, bgcolor: Colors.YELLOW }, center = true) => {
    CH.show_cursor(false);
    let textArray = logo.split("\n");
    if (center) {
      const old_len = Math.max(...textArray.map((item) => item.length));
      for (let i = 0; i < textArray.length; i++) {
        textArray[i] = CH.hcenter(textArray[i], CH.getWidth());
      }
      const w_diff = textArray[1].length - old_len;
      color.index = Math.round(w_diff / 2) + color.index;
    }
    const hval = Math.max(...textArray.map((item) => item.length));
    const width = CH.getWidth();
    const get_partial = (sprite, index) => {
      let res = "";
      sprite.forEach((element) => {
        let line = element.substring(0, index);
        if (color) {
          line = CH.insert_color(color.bgcolor, line.substring(0, color.index)) + CH.insert_color(color.color, line.substring(color.index));
        }
        res += CH.hcenter(line, width);
        res += "\n";
      });
      return res;
    };
    for (let i = 0; i < hval; i++) {
      let start = Date.now();
      CH.clear_screen();
      CH.print(get_partial(textArray, i + 1));
      while (Date.now() - start < ms) {
      }
    }
  };
  static animate = (logo, ms, color = { color: Colors.RED, index: 1, bgcolor: Colors.YELLOW }, center = true, callback) => {
    CH.show_cursor(false);
    let textArray = logo.split("\n");
    if (center) {
      const old_len = Math.max(...textArray.map((item) => item.length));
      for (let i = 0; i < textArray.length; i++) {
        textArray[i] = CH.hcenter(textArray[i], CH.getWidth());
      }
      const w_diff = textArray[1].length - old_len;
      if (color)
        color.index = Math.round(w_diff / 2) + color.index;
    }
    const hval = Math.max(...textArray.map((item) => item.length));
    const width = CH.getWidth();
    const get_partial = (sprite, index) => {
      let res = "";
      sprite.forEach((element) => {
        let line = element.substring(0, index);
        if (color) {
          line = CH.insert_color(color.bgcolor, line.substring(0, color.index)) + CH.insert_color(color.color, line.substring(color.index));
        }
        res += CH.hcenter(line, width);
        res += "\n";
      });
      return res;
    };
    const render = (index) => {
      CH.clear_screen();
      CH.print(get_partial(textArray, index + 1));
      if (index < hval) {
        setTimeout(() => {
          render(index + 1);
        }, ms);
      } else {
        if (callback) {
          callback();
        }
      }
    };
    setTimeout(() => {
      render(1);
    }, ms);
  };
  static paintedConsoleAdventure = (center = true) => {
    let logo_sprite = _Logos.ConsoleAdventure.split("\n");
    const max_len = Math.max(...logo_sprite.map((item) => item.length));
    logo_sprite = logo_sprite.map((item) => item.padEnd(max_len, " "));
    const old_len = logo_sprite[1].length;
    let cut_off = _Logos.ca_cutoff;
    if (center) {
      for (let i = 0; i < logo_sprite.length; i++) {
        logo_sprite[i] = CH.hcenter(logo_sprite[i], CH.getWidth());
      }
      cut_off = Math.round((logo_sprite[1].length - old_len) / 2) + cut_off;
    }
    return logo_sprite.map((item) => CH.insert_color(Colors.YELLOW, item.substring(0, cut_off)) + CH.insert_color(Colors.GREEN, item.substring(cut_off))).join("\n");
  };
  static paintedMattediWorks = (center = true, colors = { color1: 39, color2: 208 }) => {
    let logo_sprite = _Logos.MattediWorks.split("\n");
    const max_len = Math.max(...logo_sprite.map((item) => item.length));
    logo_sprite = logo_sprite.map((item) => item.padEnd(max_len, " "));
    const old_len = logo_sprite[1].length;
    let cut_off = _Logos.mw_cutoff + 1;
    if (center) {
      for (let i = 0; i < logo_sprite.length; i++) {
        logo_sprite[i] = CH.hcenter(logo_sprite[i], CH.getWidth());
      }
      cut_off = Math.floor((logo_sprite[1].length - old_len) / 2) + cut_off;
    }
    return logo_sprite.map((item) => CH.insert_color(Colors.custom_colors(colors.color1), item.substring(0, cut_off)) + CH.insert_color(Colors.custom_colors(colors.color2), item.substring(cut_off))).join("\n");
  };
};
var GenieSprite = class _GenieSprite {
  static #image_1 = `\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28C0\u28C0\u28E0\u28C4\u28C0\u28C0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800
\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28F0\u28FF\u28FF\u28FF\u287F\u28BF\u28FF\u28FF\u28FF\u28C6\u2800\u2800\u2800\u2800\u2800\u2800\u2800
\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2839\u283F\u281B\u28C1\u28E4\u28E4\u28C8\u281B\u283F\u280F\u2800\u2800\u2800\u2800\u2800\u2800\u2800
\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28B8\u28FF\u28FF\u28FF\u28FF\u2847\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800
\u2800\u2800\u2800\u2800\u28C0\u28E4\u28F4\u28F6\u28E4\u28C8\u2819\u283B\u281F\u280B\u28C1\u28E4\u28F6\u28E6\u28E4\u28C0\u2800\u2800\u2800\u2800
\u2800\u28E4\u28FE\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28F6\u28F6\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28F7\u28E4\u2800
\u28FE\u28FF\u28FF\u28FF\u28FF\u28FF\u28E7\u28C0\u28C0\u28C0\u28C0\u28C0\u2840\u2800\u2880\u28C0\u28E0\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28F7
\u2819\u283F\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u283F\u283F\u280B\u2801\u2800\u2836\u28BF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u283F\u283F\u280B
\u2800\u2800\u2800\u2800\u2800\u28C0\u28C0\u28E4\u28E4\u28F6\u28FE\u28FF\u28F7\u28F6\u28E4\u28E4\u28C0\u28C0\u28C0\u2800\u2800\u2800\u2800\u2800
\u2800\u2800\u2800\u2800\u2800\u28BF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u287F\u2801\u2800\u2800\u2800\u2800\u2800
\u2800\u2800\u2800\u2800\u2800\u2818\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u287F\u2801\u2800\u2800\u2800\u2800\u2800\u2800
\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800
\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u28BF\u28FF\u28FF\u28FF\u283F\u281F\u281B\u2889\u28C4\u2800\u2800\u2800\u2800\u2800\u2800\u2800
\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2820\u28A4\u28E4\u28F6\u28FE\u28FF\u28FF\u28FF\u28F6\u28F6\u28F6\u2836\u2812\u2800
\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u2809\u2819\u281B\u2809\u2809\u2809\u2800\u2800\u2800\u2800`;
  static #image_2 = `
\u2800\u2800\u2800\u2800\u2800\u2880\u28F4\u28FE\u28FF\u28FF\u28FF\u28FF\u28F7\u28E6\u2840\u2800\u2800\u2800\u2800\u2800
\u2800\u2800\u2800\u2800\u2800\u28B8\u28FF\u281F\u280B\u28C9\u28C9\u2819\u283B\u28FF\u2847\u2800\u2800\u2800\u2800\u2800
\u2800\u2800\u2800\u2800\u2800\u2800\u2809\u28A0\u28FE\u28FF\u28FF\u28F7\u2844\u2809\u2800\u2800\u2800\u2800\u2800\u2800
\u2800\u2800\u2800\u2800\u28C0\u28E4\u2844\u2818\u28FF\u28FF\u28FF\u28FF\u2803\u28A0\u28E4\u28C4\u2840\u2800\u2800\u2800
\u2800\u2880\u28F4\u28FF\u28FF\u28FF\u28FF\u28E6\u28C8\u2809\u2809\u28C1\u28F4\u28FF\u28FF\u28FF\u28FF\u28F7\u28C4\u2800
\u2800\u28FE\u28FF\u28FF\u28FF\u287F\u281B\u281B\u281B\u281B\u281B\u281B\u281B\u281B\u28BF\u28FF\u28FF\u28FF\u28FF\u28E7
\u28B8\u28FF\u28FF\u28FF\u28FF\u28F7\u28E4\u28E4\u28E4\u2844\u28A0\u28E4\u28E4\u28E4\u28FE\u28FF\u28FF\u28FF\u28FF\u28FF
\u2800\u28BB\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u287F\u2801\u2800\u28BB\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u280F
\u2800\u2800\u2819\u283B\u283F\u283F\u281F\u281B\u2881\u28FC\u28F7\u28C4\u2819\u281B\u283F\u283F\u283F\u281F\u2801\u2800
\u2800\u2800\u2800\u2800\u2820\u28E4\u28F6\u28FE\u28FF\u28FF\u28FF\u28FF\u28FF\u28F6\u28F6\u2800\u2800\u2800\u2800\u2800
\u2800\u2800\u2800\u2800\u2800\u283B\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u2840\u2800\u2800\u2800\u2800
\u2800\u2800\u2800\u2800\u2800\u2800\u2819\u283F\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28FF\u28C4\u2840\u2800\u2800
\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2809\u281B\u283B\u283F\u28BF\u28FF\u28FF\u28FF\u28FF\u28F7\u2804`;
  static getSprite(value) {
    if (typeof value === `boolean`)
      return value ? _GenieSprite.#image_1 : _GenieSprite.#image_2;
    const genie_seed = Math.random() > 0.5;
    if (genie_seed) {
      return _GenieSprite.#image_1;
    } else
      return CH.vcenter(_GenieSprite.#image_2.split("\n"), _GenieSprite.#image_1.split("\n").length, Math.max(..._GenieSprite.#image_1.split("\n").map((line) => line.length))).join("\n");
  }
};
var Assets_default = {
  Logos,
  GenieSprite
};

// main.js
var import_process = __toESM(require("process"), 1);
var import_readline = __toESM(require("readline"), 1);

// Game/State.js
var State = class {
  constructor(onCreate, render, changeState, onSelect) {
    if (onCreate)
      this.onCreate = onCreate;
    if (render)
      this.render = render;
    if (changeState)
      this.changeState = changeState;
    if (onSelect)
      this.onSelect = onSelect;
  }
  onCreate = () => {
  };
  changeState = (input) => {
  };
  render = (current_option) => {
  };
  onSelect(key) {
  }
  rerender = () => {
    this.onCreate();
    this.render();
  };
};

// Game/Sim.js
var CH2 = new BasicConsole();
var Colors2 = DefaultColors;
var SchedulerTypes = {
  ROUND_ROBIN: 0,
  PRIORITY: 1,
  ESF: 2,
  FIFO: 3,
  LIFO: 4
};
var Simulator = class {
  constructor() {
    this.states = [];
    this.timer = null;
    this.index = 0;
    this.maxIndex = 0;
    this.firstChar = true;
    this.config = [
      {
        name: "Scheduler Type",
        value: 0,
        min: 0,
        max: 4
      },
      {
        name: "Time Quantum",
        value: 0,
        min: 1,
        max: Math.pow(2, 32) - 1
      },
      {
        name: "Number of Processors",
        value: 1,
        min: 1,
        max: 32
      }
    ];
    this.WelcomeScreen = new State(
      () => {
        CH2.printFigLet("Scheduler Simulator");
        CH2.print("\n\n");
        let key = CH2.insert_format({
          color: Colors2.YELLOW,
          decoration: [
            Decorations.Bold,
            Decorations.Blink
          ]
        }, "key");
        CH2.hprint(`Press any ${key} to start.`);
      },
      () => {
      },
      (input) => {
        this.goToState(this.MainMenu);
      },
      (key) => {
      }
    );
    this.MainMenu = new State(
      () => {
        CH2.clear_screen();
        CH2.printFigLet("Main Menu");
        CH2.print("\n".repeat(this.config.length));
        this.maxIndex = this.config.length - 1 + 1;
      },
      () => {
        CH2.clear_last_line(this.config.length);
        for (let i = 0; i < this.config.length; i++) {
          let config = this.config[i];
          let str = `${config.name}: ${config.value}`;
          if (config.name == "Scheduler Type") {
            str += ` (${Object.keys(SchedulerTypes)[config.value]})`;
          }
          if (i == this.index) {
            str = CH2.insert_format({
              color: Colors2.BLACK,
              background: Colors2.BG_WHITE
            }, str);
          }
          CH2.hprint(str);
        }
      },
      (input) => {
        if (input == "arrowup") {
          this.index--;
          this.firstChar = true;
          if (this.index < 0) {
            this.index = 0;
          }
        } else if (input == "arrowdown") {
          this.index++;
          this.firstChar = true;
          if (this.index >= this.maxIndex) {
            this.index = 0;
          }
        } else if (input == "arrowleft") {
          if (this.index == 0) {
            return;
          }
          let config = this.config[this.index - 1];
          config.value--;
          if (config.value < config.min) {
            config.value = config.max;
          }
        } else if (input == "arrowright") {
          if (this.index == 0) {
            return;
          }
          let config = this.config[this.index - 1];
          config.value++;
          if (config.value > config.max) {
            config.value = config.min;
          }
        } else if (input == "backspace") {
          let config = this.config[this.index - 1];
          let val_str = config.value.toString();
          if (val_str.length > 1) {
            val_str = val_str.slice(0, -1);
          } else {
            val_str = "0";
          }
          config.value = parseInt(val_str);
        } else if (input[0] >= "0" && input[0] <= "9") {
          let val = parseInt(input[0]);
          let config = this.config[this.index];
          if (this.index != 0 && !this.firstChar) {
            val += config.value * 10;
            this.firstChar = false;
          }
          if (val > config.max) {
            val = config.max;
          } else if (val < config.min) {
            val = config.min;
          }
          config.value = val;
        }
      },
      (key) => {
      }
    );
  }
  goToState(state) {
    this.states.unshift(state);
    this.firstChar = true;
    state.onCreate();
    state.render();
  }
  goBack() {
    if (this.states.length > 1) {
      this.states.pop().end();
      this.states[this.states.length - 1].render();
    }
  }
  getCurrentState() {
    if (this.states.length > 0) {
      return this.states[0];
    }
    return null;
  }
  end() {
    CH2.clear_last_line(1);
    CH2.print("Game Over");
    process.exit(0);
  }
  handleInput(input) {
    this.getCurrentState()?.changeState(input);
    this.getCurrentState()?.render();
  }
};

// main.js
var CH3 = new BasicConsole();
var Colors3 = DefaultColors;
import_process.default.stdin.setRawMode(true);
import_readline.default.emitKeypressEvents(import_process.default.stdin);
CH3.setTitle("Scheduler Simulator");
var sim = new Simulator();
CH3.show_cursor(false);
var lock = true;
CH3.merge(Assets_default.Logos.Mattedi, Assets_default.Logos.Works, { padding: 0 }).split("\n").forEach((line) => {
  console.log(CH3.getLineWidth(line, CH3.getWidth()));
});
var perfectpaintedMw = CH3.merge(
  CH3.paint(Assets_default.Logos.Mattedi, Colors3.custom_colors(39)),
  CH3.paint(Assets_default.Logos.Works, Colors3.custom_colors(208)),
  { padding: 0 }
);
CH3.animate(
  perfectpaintedMw,
  10,
  () => {
    lock = false;
    setTimeout(() => {
      sim.goToState(sim.WelcomeScreen);
    }, 1e3);
  },
  true
);
import_process.default.stdout.on("resize", () => {
});
var delCount = 0;
import_process.default.stdin.on("keypress", (key, data) => {
  if (lock)
    return;
  if (delCount > 0) {
    CH3.clear_last_line(delCount);
    delCount = 0;
  }
  let input = "";
  if (typeof data.name === "undefined") {
    input = data.sequence;
  } else if (data.name === "up") input = "arrowup";
  else if (data.name === "down") input = "arrowdown";
  else if (data.name === "left") input = "arrowleft";
  else if (data.name === "right") input = "arrowright";
  else if (data.name === "space") input = "space";
  else if (data.name === "return") input = "enter";
  else if (data.name === "escape") input = "esc";
  else if (data.name === "backspace") input = "backspace";
  else input = data.name;
  if (data.ctrl && data.name === "d") {
    delCount += CH3.controlPrint("Width: " + CH3.getWidth());
    console.log("del: " + delCount++);
  } else {
    sim.handleInput(input);
  }
  if (data && data.ctrl && data.name === "c") {
    console.clear();
    CH3.write("\x1B[3J");
    CH3.show_cursor(true);
    import_process.default.exit();
  }
});
